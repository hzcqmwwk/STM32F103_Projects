D:\STM32F103_Projects\学习例程\笔记中有markdown文件形式的  FreeRTOS任务相关的其他API函数  介绍

任务创建和删除: 
    动态创建任务: 
        xTaskCreate((TaskFunction_t) pxTaskCode,     // 任务函数(指向任务函数的指针)
                    (const char *)   pcName,         // 任务名称
                    (uint16_t)       usStackDepth,   // 任务堆栈大小，单位为字，在stm32中1字=4字节=32位
                    (void *)         pvParameters,   // 传入给任务函数的参数(无为NULL)
                    (UBaseType_t)    uxPriority,     // 任务优先级
                    (TaskHandle_t *) pxCreatedTask); // 任务句柄(传入地址)
    静态创建任务(需定义空闲任务（必须）和定时器任务（可选）的任务堆栈和任务控制块（TCB），使用以下两个接口函数)：
        xTaskCreateStatic((TaskFunction_t) pxTaskCode,       // 任务函数(指向任务函数的指针)
                          (char *)         pcName,           // 任务名称
                          (uint32_t)       ulStackDepth,     // 任务堆栈大小
                          (void *)         pvParameters,     // 传入给任务函数的参数(无为NULL)
                          (UBaseType_t)    uxPriority,       // 任务优先级
                          (StackType_t *)  puxStackBuffer,   // 任务堆栈，一般为数组，由用户自分配
                          (StaticTask_t *) pxTaskBuffer);    // 任务句柄，任务控制块指针，由用户分配(用taskhandle_t定义,传入地址)
            空闲任务内存分配
            void vApplicationGetIdleTaskMemory((StaticTask_t **) ppxIdleTaskTCBBuffer,	  //空闲任务控制块
                                               (StackType_t **) ppxIdleTaskStackBuffer,   //空闲任务栈空间
                                               (uint32_t *)     pulIdleTaskStackSize)     //空闲任务栈空间大小
            软件定时器任务内存分配
            void vApplicationGetTimerTaskMemory((StaticTask_t **) ppxTimerTaskTCBBuffer,	//软件定时器任务控制块
                                                (StackType_t **) ppxTimerTaskStackBuffer,  //软件定时器任务栈空间
                                                (uint32_t *)     pulTimerTaskStackSize)      //软件定时器任务栈空间大小
    删除任务: 
        vTaskDelete((TaskHandle_t) xTaskToDelete)//待删除任务的任务句柄,NULL为删除自身（当前正在运行的任务）

任务挂起和恢复：
    任务挂起：
        vTaskSuspend((TaskHandle_t) xTaskToSuspend)//待挂起任务句柄
    任务恢复：
        vTaskResume((TaskHandle_t) xTaskToResume)//待恢复任务句柄
    在中断中恢复被挂起的任务: 
        xTaskResumeFromISR((TaskHandle_t) xTaskToResume)//待恢复任务句柄

临界区代码保护：
    任务级进入临界段：
        taskENTER_CRITICAL()
    任务级退出临界段：
        taskEXIT_CRITICAL()
    中断级进入临界段：
        taskENTER_CRITICAL_FROM_ISR()
    中断级退出临界段：
        taskEXIT_CRITICAL_FROM_ISR()

任务调度器的挂起和恢复：
    挂起任务调度器：
        vTaskSuspendAll()
    恢复任务调度器：
        xTaskResumeAll()

列表和列表项：
    列表初始化：
        vListInitialise((List_t *)pxList)//待初始化列表的地址
    列表项初始化：
        vListInitialiseItem((ListItem_t *)pxItem)//待初始化列表项的地址
    列表项插入
        vListInsert((List_t *)pxList,                   //待插入列表的地址
                    (ListItem_t *)pxNewListItem)        //插入列表项的地址
    末尾列表项插入：
        vListInsertEnd((List_t *)pxList,                //待插入列表的地址
                       (ListItem_t *)pxNewListItem)     //末尾插入的列表项的地址(插入至列表指针指向的列表项前一个)
    列表项移除：
        uxListRemove((ListItem_t *)pxItemToRemove)//需移除的列表项的地址

任务相关API(主要用于程序调试阶段，查看任务运行状态，以及统计任务时间占比（空闲任务占比越大，代表应用程序压力越小):
    获取任务优先级：
        uxTaskPriorityGet((TaskHandle_t)xTask)      //带入任务句柄(NULL为自身)
    设置任务优先级：
        vTaskPrioritySet((TaskHandle_t)xTask, (UBaseType_t)uxNewPriority)   //带入任务句柄(NULL为自身),待设置的优先级
    获取系统中任务的数量：
        uxTaskGetNumberOfTasks()
    获取所有任务的任务信息：
        uxTaskGetSystemState((TaskStatus_t *)pxTaskStatusArray, // 指向TaskStatus_t结构体数组首地址
                             (UBaseType_t)uxArraySize,          // 接收信息的数组大小
                             (uint32_t *)pulTotalRunTime);      // 系统总运行时间，为NULL则省略总运行时间值
    获取指定任务的任务信息：
        vTaskGetInfo((TaskHandle_t)xTask,                   // 指定获取信息的任务的句柄
                     (TaskStatus_t *)pxTaskStatus,          // 接收任务信息的变量
                     (BaseType_t)xGetFreeStackSpace,        // 任务栈历史剩余最小值，为pdFALSE则跳过，为pdTRUE则检查历史剩余最小堆栈
                     (eTaskState)eState);                   // 任务状态，可直接赋值，如想获取代入"eInvalid"
    获取当前任务的任务句柄：
        xTaskGetCurrentTaskHandle()
    根据任务名获取该任务的任务句柄：
        xTaskGetHandle((char *)pcNameToQuery)  // 任务名
    获取任务的任务栈历史剩余最小值(用于确定该设置多大的任务堆栈)：
        uxTaskGetStackHighWaterMark((TaskHandle_t)xTask)
    获取任务状态：
        eTaskGetState((TaskHandle_t)xTask)  返回值：// 0:eRunning运行态
                                                   // 1:eReady就绪态
                                                   // 2:eBlocked阻塞态
                                                   // 3:eSuspended挂起态
                                                   // 4:eDeleted任务被删除
                                                   // 5:eInvalid无效
    以“表格”形式获取所有任务的信息：
        vTaskList((char *)pcWriteBuffer)  // 接收任务信息的缓存指针
                                          // 任务名称，任务状态，任务优先级，堆栈历史最小剩余大小，任务编号
                                          // X:运行态,B:阻塞态,R:就绪态,S:挂起态,D:删除态
    获取任务的运行时间(获取每个任务的运行时间，并统计每个任务占用CPU的时间百分比)：
        vTaskGetRunTimeStats((char *)pcWriteBuffer)
        //需要配置FreeRTOSRunTimeTicks变量和ConfigureTimeForRunTimeStats()函数

延时函数：
    相对延时(每次延时都是从执行函数vTaskDelay()开始，直到延时指定的时间结束)：
        vTaskDelay((TickType_t)xTicksToDelay)//需延时的毫秒数
    绝对延时(将整个任务的运行周期看成一个整体，适用于需要按照一定频率运行的任务)：
        vTaskDelayUntil((TickType_t *)pxPreviousWakeTime,(TickType_t)xTimeIncrement)//初始时间，需延时的毫秒数

消息队列：
    创建队列：
        动态创建：
            xQueueCreate(uxQueueLength, uxItemSize) //创建队列的长度（项目个数），单个项目的字节大小，返回值：列表句柄
        静态创建：
            xQueueCreateStatic()
    写队列（入队）：
        往队列的尾部写入消息：
            xQueueSend(xQueue, pvItemToQueue, xTicksToWait)//队列句柄，写入值的地址，阻塞超时时间
                                            //阻塞超时时间：0:队列满时不写入，x:等x毫秒，portMAX_DELAY:死等，一直到能写入时再写入
        往队列的尾部写入消息：
            xQueueSendToBack(xQueue, pvItemToQueue, xTicksToWait)//队列句柄，写入值的地址，阻塞超时时间
        往队列的头部写入消息：
            xQueueSendToFront(xQueue, pvItemToQueue, xTicksToWait)//队列句柄，写入值的地址，阻塞超时时间
        覆写队列消息（只用于队列长度为 1 的情况）：
            xQueueOverwrite(xQueue, pvItemToQueue)//队列句柄，写入值的地址
        在中断中往队列的尾部写入消息：
            xQueueSendFromISR(xQueue, pvItemToQueue, xTicksToWait)//队列句柄，写入值的地址，阻塞超时时间
        在中断中往队列的尾部写入消息：
            xQueueSendToBackFromISR(xQueue, pvItemToQueue, xTicksToWait)//队列句柄，写入值的地址，阻塞超时时间 
        在中断中往队列的头部写入消息：
            xQueueSendToFrontFromISR(xQueue, pvItemToQueue, xTicksToWait)//队列句柄，写入值的地址，阻塞超时时间 
        在中断中覆写队列消息：
            xQueueOverwriteFromISR(xQueue, pvItemToQueue)//队列句柄，写入值的地址
    读队列（出队）：
        从队列头部读取消息，并删除消息：
            xQueueReceive(xQueue, pvBuffer, xTicksToWait) //队列句柄，读取后放入的地址，阻塞超时时间
        从队列头部读取消息：
            xQueuePeek(xQueue, pvBuffer, xTicksToWait) //队列句柄，读取后放入的地址，阻塞超时时间 
        在中断中从队列头部读取消息，并删除消息：
            xQueueReceiveFromISR(xQueue, pvBuffer, xTicksToWait) //队列句柄，读取后放入的地址，阻塞超时时间 
        在中断中从队列头部读取消息：
            xQueuePeekFromISR(xQueue, pvBuffer, xTicksToWait) //队列句柄，读取后放入的地址，阻塞超时时间

信号量：
    释放信号量(计数值+1)：
        xSemaphoreGive(xSemaphore)//信号量句柄
    获取信号量(计数值-1)：
        xSemaphoreTake(xSemaphore, xBlockTime)//信号量句柄，阻塞时间
                                        //阻塞超时时间：0:不阻塞 直接获取失败，x:等x毫秒，portMAX_DELAY:死等，一直到能获取时再获取
    创建二值信号量：
        xSemaphoreCreateBinary()
    创建互斥信号量：
        xSemaphoreCreateMutex()    
    创建计数型信号量：
        xSemaphoreCreateCounting(uxMaxCount, uxInitialCount)//计数值最大值，计数值起始值
    获取信号量当前计数值：
        uxSemaphoreGetCount(xSemaphore)//信号量句柄

队列集：
    创建队列集：
        xQueueCreateSet(uxEventQueueLength)//存放队列的数量
    队列添加到队列集中：
        xQueueAddToSet(xQueueOrSemaphore,xQueueSet)//添加的队列句柄，要进的队列集句柄
    从队列集中移除队列：
        xQueueRemoveFromSet(xQueueOrSemaphore,xQueueSet)//要移除的队列句柄，对应队列集句柄
    获取队列集中有有效消息的队列：
        xQueueSelectFromSet(xQueueSet,xTicksToWait)//队列集句柄，阻塞时间
    在中断中获取队列集中有有效消息的队列：
        xQueueSelectFromSetFromISR(xQueueSet,xTicksToWait)//队列集句柄，阻塞时间

事件标志组：
    创建事件标志组(动态)：
        xEventGroupCreate()//16位或32位，高8位不用
    设置事件标志位：
        xEventGroupSetBits(xEventGroup,uxBitsToSet)//事件标志组句柄，需置1的标志位
    清零事件标志位：
        xEventGroupClearBits(xEventGroup,uxBitsToSet)//事件标志组句柄，需清0的标志位
    等待事件标志位：
        xEventGroupWaitBits(xEventGroup,     // 等待的事件标志组句柄
                            uxBitsToWaitFor, // 等待的事件标志位
                            xClearOnExit,    // 成功等待后是否清除对应的标志位,pdTRUE：清除，pdFALSE：不清除
                            xWaitForAllBits, // 是否等待全部事件标志位，pdTRUE：等待的位 全部为1，pdFALSE：等待的位 某个为1
                            xTicksToWait)    // 阻塞时间,portMAX_DELAY 死等
    同步函数(设置事件标志位，并等待事件标志位)：
        xEventGroupSync(xEventGroup,      // 事件标志组句柄
                        uxBitsToSet,      // 设置的事件标志位
                        uxBitsToWaitFor,  // 等待的事件标志位
                        xTicksToWait)     // 阻塞时间

任务通知：
    发送通知(带有通知值)：
        xTaskNotify(xTaskToNotify,ulValue,eAction)//接收的任务句柄，发送的通知值，更新方式
    发送通知(带有通知值并且保留接收任务的原通知值)：
        xTaskNotifyAndQuery(xTaskToNotify,          // 接收的任务句柄，
                            ulValue,                // 发送的通知值，
                            eAction,                // 通知方式，
                            pulPreviousNotifyValue) // 用于保存原通知值的地址
                                                    //通知方式： eNoAction = 0, 			 /* 无操作 */
                                                                eSetBits				    /* 更新指定bit */
                                                                eIncrement				    /* 通知值加一 */
                                                                eSetValueWithOverwrite		/* 覆写的方式更新通知值 */
                                                                eSetValueWithoutOverwrite	/* 不覆写通知值 */
    获取通知(用于模拟队列，事件标志组)：
        xTaskNotifyWait(ulBitsToClearOnEntry,    // 等待前清零通知值的bit位
                        ulBitsToClearOnExit,     // 成功等待后清零通知值的bit位(通知值为32位)
                        pulNotificationValue,    // 取出通知值(带入地址，不取出为NULL)
                        xTicksToWait);           // 阻塞时间

    发送通知(不带通知值用于模拟信号量)：
        xTaskNotifyGive(xTaskToNotify) // 接收的任务句柄
    获取通知(用于获取信号量)：
        ulTaskNotifyTake(xClearCountOnExit,xTicksToWait) // 接收后把通知值清零或减1，pdTRUE：清零，pdFALSE：减1 ， 阻塞时间

软件定时器：
    创建定时器(动态)：
        xTimerCreate((char *)pcTimerName,                         // 定时器名字
                     (TickType_t)xTimerPeriodInTicks,             // 超时周期(ms)
                     (UBaseType_t)uxAutoReload,                   // pdTRUE周期定时器，pdFALSE单次定时器
                     (void *)pvTimerID,                           // 软件定时器ID，用于多个软件定时器共用一个超时回调函数
                     (TimerCallbackFunction_t)pxCallbackFunction) // 超时回调函数
        xTimerCreateFromISR() //中断级
    开启定时器：
        xTimerStart(xTimer,xTicksToWait)   // 待开启定时器的句柄，发送命令阻塞时间 
        xTimerStartFromISR()//中断级
    停止定时器：
        xTimerStop(xTimer,xTicksToWait)    // 待停止定时器的句柄，发送命令阻塞时间
        xTimerStopFromISR()//中断级
    复位定时器：
        xTimerReset(xTimer,xTicksToWait)   // 待复位定时器的句柄，发送命令阻塞时间
        xTimerResetFromISR()//中断级
    删除定时器：
        xTimerDelete(xTimer,xTicksToWait)   // 待删除定时器的句柄，发送命令阻塞时间
        xTimerDeleteFromISR()//中断级
    更改定时器超时时间：
        xTimerChangePeriod(xTimer,xNewPeriod,xTicksToWait) // 定时器句柄，新的超时时间，发送命令阻塞时间
        xTimerChangePeriodFromISR()//中断级
    //不能在超时回调函数中使用可能会导致任务阻塞的 API 函数

内存管理：
    申请内存：
        pvPortMalloc(size_t xWantedSize)//需申请的内存的大小，返回申请的内存的首地址
    释放内存：
        vPortFree(void * pv)//需释放的内存的首地址
    获取当前空闲任务的大小：
        xPortGetFreeHeapSize()//返回当前空闲任务大小的值
